---
title: "AIエージェントの構成"
tags: [基礎, 設計, 構成要素, 運用, パターン, ワークフロー, ツール, 全フェーズ]
created: 2026-02-25
updated: 2026-02-26
---

## AIエージェントの内部構成

[[AIエージェント]]の内部は、大きく分けて5つの構成要素で成り立っています。(1)[[プロフィール]]：エージェントの役割・専門性の定義。(2)[[ツール呼び出し]]：外部システムとのインタラクション。(3)[[計画]]：タスクの分解と実行順序の決定。(4)[[自己修正]]：実行結果の検証と修正。(5)[[メモリ]]：経験と知識の蓄積。これらを[[知覚]]（環境からの入力受信）が支えます。エージェントの「環境」とは、ユーザーインターフェース、利用可能なツール群、アクセス可能なデータソースなど、エージェントが相互作用する全てを指します。

## プロフィール（Profile）

[[プロフィール]]はエージェントの「人格」を定義するシステムプロンプトです。役割（「あなたはヘルプデスク担当のAIです」）、専門領域、行動指針、出力形式のルールなどを含みます。実装上の注意点として、プロフィールが長すぎるとLLMの注意が分散するため、最も重要な指示を先頭に配置すること。また、禁止事項よりも推奨行動を明記する方が効果的です。[[知覚]]の設計も重要で、ユーザー入力のフォーマット変換やマルチモーダル入力（画像・音声）の処理方法をプロフィール内で定義することがあります。

## ツール呼び出しとMCP

[[ツール呼び出し]]はエージェントが外部世界に働きかける手段です。LLMが関数名と引数をJSONで出力し、ランタイムが実際の関数を実行して結果をLLMに返します。ツール設計で気を付けたいのは、(1)ツールの説明文を明確にする（LLMはこの説明でツール選択を判断する）、(2)引数の型とバリデーションを厳密にする、(3)ツール数を適度に保つ（多すぎると選択精度が下がる）ことです。[[Model Context Protocol（MCP）]]は、ツール接続を標準化するプロトコルで、USBのように異なるツールを統一的なインターフェースで接続可能にします。MCPにより、ツールの再利用性と相互運用性が大幅に向上します。

## 計画（Planning）

[[計画]]はエージェントのタスク分解と実行戦略の決定プロセスです。計画には2つのアプローチがあります。(1)事前計画：タスク全体を最初に分解し、サブタスクのリストを生成する。(2)動的計画：1ステップずつ実行し、結果に応じて次のステップを決定する。[[Plan-and-Execute型]]は事前計画の代表で、計画フェーズと実行フェーズを明確に分離します。実装上の注意点として、計画が粗すぎると実行時に判断が曖昧になり、細かすぎると計画自体のコストが増大します。また、計画は固定ではなく、実行結果に応じて修正（再計画）できる設計にすることが重要です。

## 自己修正（Self-Correction）

[[自己修正]]はエージェントが自身の出力を検証し、問題を修正するメカニズムです。具体的には、(1)出力の検証（生成したコードの構文チェック、回答の整合性確認）、(2)エラーのリトライ（APIエラー時の再試行、異なるアプローチでの再実行）、(3)[[リフレクション]]（出力を振り返り品質を評価して改善する）の3つが主な手法です。実装上の注意点として、自己修正ループに上限回数を設けないと無限ループに陥るリスクがあります。また、修正の判断基準を明確にすること（何をもって「正しい」とするか）が重要です。

## メモリ（Memory）

[[メモリ]]はエージェントが情報を保持・活用する仕組みです。(1)短期メモリ：現在の会話やタスクのコンテキスト。LLMのコンテキストウィンドウに相当し、会話が長くなると古い情報が失われる。(2)長期メモリ：永続化された知識・経験。ベクトルデータベースやファイルに保存し、必要時に検索して活用する。実装上の注意点として、短期メモリの管理では重要な情報の要約や優先度付けが必要です。長期メモリでは、保存する情報の選別基準と検索の精度が品質を左右します。メモリは[[エージェントの自己改善]]にも活用でき、過去の成功・失敗パターンから学習することで継続的にパフォーマンスを向上させます。

## ワークフロー：シングルとマルチエージェント

[[シングルエージェントワークフロー]]は1つのエージェントが全処理を担当します。コード生成→実行→検証のサイクルが典型例で、シンプルで管理しやすい反面、複雑なタスクには限界があります。実装上の注意点は、ループ回数の上限設定と、各ステップの入出力の型を明確にすることです。[[マルチエージェントワークフロー]]は複数の専門エージェントが協調します。パターンとして、(1)オーケストレーター型：1つの統括エージェントが他を指揮、(2)議論型：エージェント同士が議論して合意形成、(3)階層型：上位が計画、下位が実行。実装上の注意点は、エージェント間の通信プロトコルの統一、デッドロック防止、全体の状態管理です。[[AIワークフロー]]はエージェントほど自律的ではなく、事前定義されたフローに沿って処理する仕組みで、予測可能性が高いのが特徴です。推論モデル（o1等）はエージェントの計画・推論フェーズで特に有効ですが、応答速度とコストのトレードオフを考慮する必要があります。

## 用語

- **Agent Profile（エージェントプロフィール）**: エージェントの役割・性格・専門領域・行動指針をシステムプロンプトとして定義したもの。プロフィール設計がエージェントの振る舞いの質を大きく左右する。
- **Tool Use / Function Calling（ツール呼び出し）**: LLMが外部のAPI・データベース・検索エンジン等のツールを呼び出す機能。LLMが「どのツールを」「どの引数で」呼ぶかをJSON形式で出力し、実行結果をLLMに返すことで、LLM単体ではできない操作を実現する。
- **Planning（計画（プランニング））**: エージェントが目標達成のために、タスクを分解し実行順序を決定するプロセス。計画の質がエージェント全体の成否を左右する。事前計画と動的再計画の2種類がある。
- **Self-Correction（自己修正）**: エージェントが自身の出力や行動の結果を評価し、誤りを検出して修正するメカニズム。リトライ、出力の再検証、代替手段への切り替えなどの戦略がある。
- **Agent Memory（エージェントメモリ）**: エージェントが過去の経験・会話履歴・学習した知識を保持する仕組み。短期メモリ（現在の会話コンテキスト）と長期メモリ（永続化された知識・経験）に分かれる。
- **Perception（知覚）**: エージェントが環境からの情報（ユーザー入力、ツール実行結果、外部データ）を受け取り解釈するプロセス。マルチモーダル入力（テキスト・画像・音声）の処理も含む。
- **Model Context Protocol (MCP)（モデルコンテキストプロトコル）**: Anthropicが提唱する、AIモデルと外部ツール・データソースを標準的な方法で接続するオープンプロトコル。USBのように、様々なツールをエージェントに統一的なインターフェースで接続できる。
- **Plan-and-Execute（計画実行型）**: まず全体計画を立て、その計画に基づいてサブタスクを順次実行するエージェントパターン。計画フェーズと実行フェーズを分離することで、複雑なタスクを体系的に処理する。実行結果に応じた計画の修正（再計画）も含む。
- **Reflection（リフレクション）**: エージェントが自身の出力を振り返り、品質を評価・改善するプロセス。コード生成後にエラーを検出して修正する、回答の正確性を自己チェックするなど。自己修正の具体的な実装手法の一つ。
- **Agent Architecture Self-Improvement（エージェントの自己改善）**: エージェントが運用中の経験から学び、プロンプト・ツール選択・ワークフロー自体を改善する仕組み。メモリに蓄積された成功・失敗パターンを活用し、継続的にパフォーマンスを向上させる。
- **Single-Agent Workflow（シングルエージェントワークフロー）**: 1つのエージェントが全ての処理を担当するワークフロー。シンプルで管理しやすいが、複雑なタスクでは限界がある。コード生成→実行→リフレクションのサイクルが典型例。
- **Multi-Agent Workflow（マルチエージェントワークフロー）**: 複数の専門エージェントが協調してタスクを遂行するワークフロー。各エージェントに異なる役割を割り当て、連携させることで複雑な問題に対応する。オーケストレーター型、議論型、階層型などのパターンがある。
- **AI Workflow（AIワークフロー）**: LLMの呼び出しとツール実行を、事前定義されたフローに基づいて制御する仕組み。エージェントほど自律的ではないが、予測可能性が高く、特定の業務プロセスの自動化に適している。エージェントの構成要素としても使われる。
