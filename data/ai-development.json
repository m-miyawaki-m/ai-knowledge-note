{
  "category": "ai-development",
  "displayName": "AI開発活用",
  "description": "ソフトウェア開発の各フェーズでAIを活用する考え方と手法。特定ツールに依存しない概念的な理解を目指す。",
  "topics": [
    {
      "id": "aidev-topic-requirements",
      "term": "Requirements Definition with AI",
      "termJa": "要件定義でのAI活用",
      "meaning": "顧客要望の構造化、要件の矛盾・曖昧さ検出など、要件定義フェーズでAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "AIで要件を整理する",
            "body": "顧客やステークホルダーからのヒアリング結果は、多くの場合自然言語で書かれた曖昧な文書です。AIの[[aidev-term-nlp|自然言語処理]]能力を活用することで、これらの文書から要件を構造化できます。[[aidev-term-prompt-engineering|プロンプトエンジニアリング]]によって、AIに「この文書から機能要件と非機能要件を分類して」と指示すれば、要件の初期整理を効率化できます。[[aidev-term-few-shot|Few-shot Learning]]の手法で、過去の要件定義書の例を数件提示すると、プロジェクトの文脈に沿った出力が得られやすくなります。",
            "termRefs": ["aidev-term-nlp", "aidev-term-prompt-engineering", "aidev-term-few-shot"]
          },
          {
            "heading": "要件の矛盾と曖昧さを検出する",
            "body": "要件定義で最も厄介なのは、要件間の矛盾や曖昧な記述です。AIに要件一覧を入力し、「矛盾する要件はないか」「曖昧な表現はどこか」と問いかけることで、人間が見落としがちな問題を発見できます。ただし、AIの出力には[[aidev-term-hallucination|ハルシネーション]]のリスクがあります。存在しない矛盾を指摘したり、実際の矛盾を見逃す可能性があるため、AIの指摘は必ず人間が確認する必要があります。",
            "termRefs": ["aidev-term-hallucination"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-requirements-extraction", "aidev-concept-requirements-validation"]
    },
    {
      "id": "aidev-topic-basic-design",
      "term": "Basic Design with AI",
      "termJa": "基本設計でのAI活用",
      "meaning": "システム全体のアーキテクチャ設計や技術選定にAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "アーキテクチャの探索",
            "body": "基本設計では、システム全体の構造を決定します。AIに対して「このような要件を満たすアーキテクチャパターンを提案して」と[[aidev-term-chain-of-thought|Chain-of-Thought]]形式で段階的に考えさせることで、マイクロサービスかモノリスか、どのデータベースが適切かといった設計判断の検討材料を得られます。[[aidev-term-rag|RAG]]を活用し、社内の過去の設計書を参照させることで、組織固有のアーキテクチャ標準に沿った提案も可能です。",
            "termRefs": ["aidev-term-chain-of-thought", "aidev-term-rag"]
          },
          {
            "heading": "技術選定の比較検討",
            "body": "技術選定では、複数の選択肢の比較が必要です。AIの[[aidev-term-context-window|コンテキストウィンドウ]]に各技術の特徴、プロジェクトの制約条件、チームのスキルセットを入力し、比較表や判断根拠を生成させることができます。ただし、AIの知識には学習時点のカットオフがあるため、最新のバージョン情報やライセンス変更は人間が確認する必要があります。",
            "termRefs": ["aidev-term-context-window"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-architecture-exploration", "aidev-concept-technology-comparison"]
    },
    {
      "id": "aidev-topic-outline-design",
      "term": "Outline Design with AI",
      "termJa": "概要設計でのAI活用",
      "meaning": "モジュール分割やインターフェース設計、既存コードの理解にAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "モジュール分割とインターフェース設計",
            "body": "概要設計では、システムをモジュールに分割し、モジュール間のインターフェースを定義します。AIに要件と基本設計の情報を与え、モジュール分割案やAPI定義を提案させることができます。[[aidev-term-ai-review|AIレビュー]]として、設計したインターフェース定義の整合性チェックを依頼することも有効です。ただし、入力情報が[[aidev-term-context-window|コンテキストウィンドウ]]を超える大規模システムでは、情報を分割して入力する工夫が必要です。",
            "termRefs": ["aidev-term-ai-review", "aidev-term-context-window"]
          },
          {
            "heading": "既存コードベースの理解",
            "body": "既存システムの改修案件では、まず現在のコードを理解する必要があります。[[aidev-term-code-analysis|コード解析]]をAIに依頼し、モジュール構成やデータフローを可視化できます。[[aidev-term-embedding-search|エンベディング検索]]を使えば、関連するコード断片を意味的に検索することも可能です。「この関数の役割は何か」「このモジュール間の依存関係を説明して」といった質問で、大規模コードベースの把握を効率化できます。AIの解釈には[[aidev-term-hallucination|ハルシネーション]]のリスクがあるため、重要な理解はコードを直接確認して裏付けましょう。",
            "termRefs": ["aidev-term-code-analysis", "aidev-term-embedding-search", "aidev-term-hallucination"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-module-decomposition", "aidev-concept-codebase-understanding"]
    },
    {
      "id": "aidev-topic-detailed-design",
      "term": "Detailed Design with AI",
      "termJa": "詳細設計でのAI活用",
      "meaning": "クラス設計やロジック設計、擬似コード生成にAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "ロジック設計と擬似コード",
            "body": "詳細設計ではクラス図やシーケンス図、具体的なアルゴリズムを定義します。AIに[[aidev-term-code-generation|コード生成]]を依頼し、設計仕様から擬似コードやインターフェース定義を作成させることで、設計と実装のギャップを減らせます。[[aidev-term-chain-of-thought|Chain-of-Thought]]で段階的にロジックを組み立てさせると、複雑なアルゴリズムでも論理の飛躍が少ない設計が得られます。",
            "termRefs": ["aidev-term-code-generation", "aidev-term-chain-of-thought"]
          },
          {
            "heading": "AIの制約を意識した設計",
            "body": "詳細設計でAIを活用する際は、[[aidev-term-token-limit|トークン制限]]を意識する必要があります。1つのクラスや関数が大きすぎると、AIが全体を把握できません。逆に言えば、AIが扱いやすい粒度で設計することは、人間にとっても読みやすい設計につながります。[[aidev-term-zero-shot|Zero-shot]]で指示が通る場合はそのまま、複雑な場合は[[aidev-term-few-shot|Few-shot Learning]]で類似の設計例を提示すると精度が上がります。",
            "termRefs": ["aidev-term-token-limit", "aidev-term-zero-shot", "aidev-term-few-shot"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-logic-design", "aidev-concept-pseudocode-generation"]
    },
    {
      "id": "aidev-topic-unit-testing",
      "term": "Unit Testing with AI",
      "termJa": "単体テストでのAI活用",
      "meaning": "テストケースの自動生成やカバレッジ向上にAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "テストケースの自動生成",
            "body": "単体テストはAI活用の恩恵が最も大きいフェーズの一つです。[[aidev-term-test-case-generation|テストケース生成]]として、実装コードをAIに入力し「このメソッドの正常系・異常系・境界値のテストケースを生成して」と依頼できます。[[aidev-term-prompt-engineering|プロンプトエンジニアリング]]で「カバレッジ100%を目指して」「境界値を重点的に」といった条件を加えると、より網羅的なテストが得られます。",
            "termRefs": ["aidev-term-test-case-generation", "aidev-term-prompt-engineering"]
          },
          {
            "heading": "テスト品質の向上",
            "body": "生成されたテストの品質を検証するには[[aidev-term-mutation-testing|ミューテーションテスト]]が有効です。ソースコードに意図的な変更（ミューテーション）を加え、テストがそれを検出できるか確認します。AIが生成したテストで検出できないミューテーションがあれば、そのケースを追加するよう[[aidev-term-ai-review|AIレビュー]]に再度依頼することで、テストの品質を反復的に高められます。",
            "termRefs": ["aidev-term-mutation-testing", "aidev-term-ai-review"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-test-generation", "aidev-concept-coverage-improvement"]
    },
    {
      "id": "aidev-topic-integration-testing",
      "term": "Integration Testing with AI",
      "termJa": "結合テストでのAI活用",
      "meaning": "シナリオベースのテスト設計や回帰テストの効率化にAIを活用する考え方。",
      "article": {
        "sections": [
          {
            "heading": "シナリオベースのテスト設計",
            "body": "結合テストでは、複数モジュールが連携する際の振る舞いを検証します。[[aidev-term-test-scenario-generation|テストシナリオ生成]]として、ユースケースや画面遷移図をAIに入力し、テストシナリオを網羅的に生成させることができます。AIは人間が見落としがちな例外パスやエッジケースの組み合わせを提案してくれます。[[aidev-term-ai-debugging|AIデバッグ]]では、テスト失敗時のログやスタックトレースをAIに分析させ、原因の特定を支援できます。",
            "termRefs": ["aidev-term-test-scenario-generation", "aidev-term-ai-debugging"]
          },
          {
            "heading": "回帰テストの効率化",
            "body": "システム変更のたびに実行する回帰テストは、テスト数の増加とともに負担が増大します。[[aidev-term-auto-regression|自動回帰テスト]]にAIを組み合わせることで、変更の影響範囲を分析し、実行すべきテストの優先順位付けが可能です。[[aidev-term-code-analysis|コード解析]]で変更の影響を受けるモジュールを特定し、関連するテストケースを重点的に実行することで、テスト時間を短縮しつつ品質を確保できます。",
            "termRefs": ["aidev-term-auto-regression", "aidev-term-code-analysis"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-scenario-design", "aidev-concept-regression-efficiency"]
    },
    {
      "id": "aidev-topic-glossary",
      "term": "Glossary-Driven Development",
      "termJa": "用語集の構築と活用",
      "meaning": "プロジェクト固有の用語集を作成し、AIの入力に活用することで出力品質と一貫性を高める手法。",
      "article": {
        "sections": [
          {
            "heading": "なぜ用語集がAI活用の鍵になるのか",
            "body": "AIは汎用的な知識を持っていますが、プロジェクト固有の略語や業務用語は知りません。「顧客マスタ」「受注伝票」「承認フロー」といった業務用語をAIに説明なく使うと、一般的な解釈で処理され、意図と異なる出力になります。[[aidev-term-glossary-driven|用語集駆動開発]]では、プロジェクトの用語・略語・業務ルールを体系的に整理し、AIへの入力に常に含めます。これにより[[aidev-term-hallucination|ハルシネーション]]を抑制し、チーム全員が同じ文脈でAIを活用できるようになります。用語集は単なる辞書ではなく、AIの出力品質を左右する重要な開発資産です。"
,
            "termRefs": ["aidev-term-glossary-driven", "aidev-term-hallucination"]
          },
          {
            "heading": "用語集をプロンプトで活用する",
            "body": "用語集のAI活用には複数のパターンがあります。最も直接的なのは、[[aidev-term-prompt-template|プロンプトテンプレート]]に用語定義セクションを設け、毎回の指示に含める方法です。例えば「以下の用語定義に従ってください：顧客マスタ＝顧客の基本情報を管理するテーブル…」とプロンプトの冒頭に置きます。[[aidev-term-few-shot|Few-shot Learning]]と組み合わせ、用語を正しく使った出力例を数件提示すると効果的です。大量の用語がある場合は、[[aidev-term-rag|RAG]]で関連用語のみを動的に検索してプロンプトに注入する方法も有効です。また、[[aidev-term-grounding|グラウンディング]]として用語集を事実の根拠に使うことで、AIが独自の解釈を加えるリスクを低減できます。",
            "termRefs": ["aidev-term-prompt-template", "aidev-term-few-shot", "aidev-term-rag", "aidev-term-grounding"]
          },
          {
            "heading": "用語集の作り方と継続的な運用",
            "body": "用語集は開発の初期フェーズで作成し、プロジェクトの進行に合わせて継続的に更新します。まず既存ドキュメントから業務用語を抽出し（この作業自体もAIに依頼可能）、定義・同義語・使い分けのルールを整理します。[[aidev-term-structured-output|構造化出力]]の形式（JSON、Markdown表など）で管理すると、プロンプトへの組み込みやツール連携が容易になります。新しい用語が登場したら都度追加し、定義が変わったら更新する。この用語集をチームの[[aidev-term-knowledge-base|ナレッジベース]]として共有すれば、メンバー間でAIの出力品質にばらつきがなくなります。",
            "termRefs": ["aidev-term-structured-output", "aidev-term-knowledge-base"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-glossary-creation", "aidev-concept-glossary-prompt-usage"]
    },
    {
      "id": "aidev-topic-prompt-patterns",
      "term": "Prompt Design Patterns",
      "termJa": "プロンプト設計パターン",
      "meaning": "開発タスクで繰り返し使える、効果的なプロンプトの設計パターンと実践手法。",
      "article": {
        "sections": [
          {
            "heading": "効果的なプロンプトの構造",
            "body": "開発でAIに指示を出す際は、4つの要素を意識します。(1)役割設定：「あなたはJavaのシニアエンジニアです」のように専門性を指定。(2)文脈提供：関連するコード、設計書、用語集を含める。(3)指示：具体的に何をしてほしいかを明確にする。(4)出力形式：「Markdown表で」「JSONで」など[[aidev-term-structured-output|構造化出力]]の形式を指定する。この4要素を[[aidev-term-prompt-template|プロンプトテンプレート]]として定型化し、タスクごとに変数部分だけ差し替えると、安定した品質の出力が得られます。",
            "termRefs": ["aidev-term-structured-output", "aidev-term-prompt-template"]
          },
          {
            "heading": "開発タスク別のプロンプトパターン",
            "body": "よく使うパターンをいくつか紹介します。「分析パターン」：コードや仕様書を与え「問題点を3つ挙げて、それぞれ根拠と改善案を示して」と[[aidev-term-chain-of-thought|Chain-of-Thought]]で段階的に分析させる。「変換パターン」：「このクラス図をAPIインターフェース定義に変換して」のように、あるドキュメント形式から別の形式への変換を依頼する。「レビューパターン」：「このコードを以下の観点でレビューして：セキュリティ、パフォーマンス、可読性」と観点を明示して[[aidev-term-ai-review|AIレビュー]]を依頼する。「生成パターン」：[[aidev-term-few-shot|Few-shot]]で類似の完成例を2-3件提示し、同じ形式での生成を依頼する。パターンを蓄積しチームで共有することで、AI活用の属人化を防げます。",
            "termRefs": ["aidev-term-chain-of-thought", "aidev-term-ai-review", "aidev-term-few-shot"]
          },
          {
            "heading": "プロンプトの改善サイクル",
            "body": "最初から完璧なプロンプトは書けません。出力を見て調整を繰り返すことが重要です。AIの出力が期待と異なる場合、指示が曖昧だったのか、文脈が不足していたのか、出力形式が不明確だったのかを分析します。改善したプロンプトは[[aidev-term-knowledge-base|ナレッジベース]]に蓄積し、チームの資産として共有しましょう。[[aidev-term-hallucination|ハルシネーション]]が頻発する領域では、「不明な点は『不明』と回答してください」「推測する場合は『推測：』と明記してください」といった[[aidev-term-grounding|グラウンディング]]の指示を加えることが有効です。",
            "termRefs": ["aidev-term-knowledge-base", "aidev-term-hallucination", "aidev-term-grounding"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-prompt-structure", "aidev-concept-prompt-iteration"]
    },
    {
      "id": "aidev-topic-rules-instructions",
      "term": "Rules & Custom Instructions",
      "termJa": "ルール・カスタム指示の活用",
      "meaning": "システムプロンプトやプロジェクトルールファイルを使い、AIの振る舞いを恒常的に制御する手法。",
      "article": {
        "sections": [
          {
            "heading": "AIへの恒常的な指示とは",
            "body": "毎回のプロンプトに同じ指示を書くのは非効率です。[[aidev-term-system-prompt|システムプロンプト]]や[[aidev-term-custom-instructions|カスタム指示]]の仕組みを使えば、プロジェクト全体に適用されるルールを一度定義するだけで済みます。例えばCLAUDE.mdや.cursorrules等のルールファイルに「コードはTypeScriptで書く」「変数名はcamelCaseを使う」「エラーメッセージは日本語にする」と定義しておけば、AIは常にこのルールに従います。これは人間の開発者にとってのコーディング規約と同じ位置づけで、AIとの協業における品質の基盤になります。",
            "termRefs": ["aidev-term-system-prompt", "aidev-term-custom-instructions"]
          },
          {
            "heading": "ルールファイルに何を書くべきか",
            "body": "効果的なルールファイルには以下の要素を含めます。(1)プロジェクト概要：技術スタック、ディレクトリ構成、主要なライブラリ。(2)コーディング規約：命名規則、インデント、コメントルール。(3)アーキテクチャ方針：レイヤー構成、依存関係のルール、禁止パターン。(4)用語定義：プロジェクト固有の[[aidev-term-glossary-driven|用語集]]への参照。(5)品質基準：テストカバレッジ目標、セキュリティ要件。これらを[[aidev-term-structured-output|構造化]]された形式で記述し、AIが正確に解釈できるようにします。ルールが多すぎると[[aidev-term-context-window|コンテキストウィンドウ]]を圧迫するため、重要度に応じた取捨選択も必要です。",
            "termRefs": ["aidev-term-glossary-driven", "aidev-term-structured-output", "aidev-term-context-window"]
          },
          {
            "heading": "ルールの階層化と使い分け",
            "body": "ルールは範囲に応じて階層化すると管理しやすくなります。全社レベル（セキュリティポリシー、共通コーディング規約）、プロジェクトレベル（技術スタック、アーキテクチャ方針）、タスクレベル（特定機能の実装方針）の3階層が一般的です。[[aidev-term-system-prompt|システムプロンプト]]に全社ルールを、プロジェクトのルールファイルにプロジェクトルールを、個々のプロンプトにタスクルールを配置します。この階層により、汎用的なルールの重複記述を避けつつ、各レベルで必要な指示を適切に伝えられます。ルールは定期的にレビューし、AIの出力品質に貢献しているか検証しましょう。",
            "termRefs": ["aidev-term-system-prompt"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-persistent-rules", "aidev-concept-rule-hierarchy"]
    },
    {
      "id": "aidev-topic-context-engineering",
      "term": "Context Engineering",
      "termJa": "コンテキストエンジニアリング",
      "meaning": "AIに提供する情報（コンテキスト）を戦略的に設計・管理し、出力品質を最大化する手法。",
      "article": {
        "sections": [
          {
            "heading": "コンテキストの設計原則",
            "body": "[[aidev-term-context-engineering|コンテキストエンジニアリング]]とは、AIに「何を」「どの順で」「どの粒度で」伝えるかを戦略的に設計することです。[[aidev-term-context-window|コンテキストウィンドウ]]には限りがあるため、すべての情報を詰め込むことはできません。重要なのは情報の優先順位付けです。(1)直接関連するコード・仕様を最優先。(2)用語集やルールで文脈を補強。(3)参考情報は必要最小限に。情報が多すぎるとAIの注意が分散し、かえって出力品質が落ちます。「このタスクに必要十分な情報は何か」を常に問いかけましょう。",
            "termRefs": ["aidev-term-context-engineering", "aidev-term-context-window"]
          },
          {
            "heading": "ナレッジベースの構築と運用",
            "body": "プロジェクトの知識を体系的に管理する[[aidev-term-knowledge-base|ナレッジベース]]は、AI活用の土台です。設計書、用語集、コーディング規約、過去の意思決定記録、よくある質問と回答をナレッジベースに蓄積します。[[aidev-term-rag|RAG]]と組み合わせれば、AIが質問に応じて関連するナレッジを自動検索し、根拠のある回答を生成できます。ナレッジベースの情報は[[aidev-term-grounding|グラウンディング]]の役割も果たし、AIが「知らないことを知らない」と判断する助けになります。ナレッジの鮮度管理も重要で、古い情報が残っているとAIが誤った前提で回答するリスクがあります。",
            "termRefs": ["aidev-term-knowledge-base", "aidev-term-rag", "aidev-term-grounding"]
          },
          {
            "heading": "実践的なコンテキスト管理テクニック",
            "body": "日常の開発で使えるコンテキスト管理のテクニックを紹介します。「スコープの明示」：AIに作業対象のファイルやモジュールを明確に伝え、無関係な範囲に手を出させない。「段階的な情報提供」：最初に概要を伝え、AIの理解を確認してから詳細を追加する。「出力の再利用」：AIが生成した中間成果物（分析結果、設計案）を次のプロンプトのコンテキストとして活用する。「[[aidev-term-prompt-template|テンプレート]]のコンテキスト枠」：プロンプトテンプレートに「プロジェクト情報」「関連コード」「用語集」の記入枠を設け、毎回漏れなく必要な情報を含めるようにする。これらの工夫により、[[aidev-term-token-limit|トークン制限]]の中で最大限の効果を引き出せます。",
            "termRefs": ["aidev-term-prompt-template", "aidev-term-token-limit"]
          }
        ]
      },
      "relatedConceptIds": ["aidev-concept-context-design", "aidev-concept-knowledge-management"]
    }
  ],
  "concepts": [
    {
      "id": "aidev-concept-requirements-extraction",
      "term": "Requirements Extraction & Structuring",
      "termJa": "要件の抽出と整理",
      "topicId": "aidev-topic-requirements",
      "meaning": "自然言語で記述された要望や議事録から、機能要件・非機能要件を抽出し構造化するプロセス。AIの自然言語処理能力とプロンプト設計を組み合わせて効率化する。",
      "relatedTermIds": ["aidev-term-nlp", "aidev-term-prompt-engineering", "aidev-term-few-shot"]
    },
    {
      "id": "aidev-concept-requirements-validation",
      "term": "Requirements Validation",
      "termJa": "要件の検証と矛盾検出",
      "topicId": "aidev-topic-requirements",
      "meaning": "定義された要件間の矛盾、曖昧さ、欠落をAIで検出するプロセス。ハルシネーションのリスクを考慮し、AIの指摘は人間が必ず確認する。",
      "relatedTermIds": ["aidev-term-hallucination"]
    },
    {
      "id": "aidev-concept-architecture-exploration",
      "term": "Architecture Exploration",
      "termJa": "アーキテクチャの探索",
      "topicId": "aidev-topic-basic-design",
      "meaning": "要件に適したアーキテクチャパターンをAIに段階的に検討させるプロセス。Chain-of-ThoughtやRAGを活用して設計の選択肢を広げる。",
      "relatedTermIds": ["aidev-term-chain-of-thought", "aidev-term-rag"]
    },
    {
      "id": "aidev-concept-technology-comparison",
      "term": "Technology Comparison",
      "termJa": "技術選定の比較検討",
      "topicId": "aidev-topic-basic-design",
      "meaning": "複数の技術候補について、AIに比較表や判断根拠を生成させるプロセス。コンテキストウィンドウの容量を活かし、多角的な比較を行う。",
      "relatedTermIds": ["aidev-term-context-window"]
    },
    {
      "id": "aidev-concept-module-decomposition",
      "term": "Module Decomposition Support",
      "termJa": "モジュール分割の支援",
      "topicId": "aidev-topic-outline-design",
      "meaning": "システムのモジュール分割案やAPI定義をAIに提案させるプロセス。AIレビューで設計の整合性を検証する。",
      "relatedTermIds": ["aidev-term-ai-review", "aidev-term-context-window"]
    },
    {
      "id": "aidev-concept-codebase-understanding",
      "term": "Codebase Understanding",
      "termJa": "既存コードの理解",
      "topicId": "aidev-topic-outline-design",
      "meaning": "既存のコードベースをAIに解析・説明させ、モジュール構成やデータフローを把握するプロセス。エンベディング検索で関連コードを意味的に検索できる。",
      "relatedTermIds": ["aidev-term-code-analysis", "aidev-term-embedding-search", "aidev-term-hallucination"]
    },
    {
      "id": "aidev-concept-logic-design",
      "term": "Logic Design Support",
      "termJa": "ロジック設計の支援",
      "topicId": "aidev-topic-detailed-design",
      "meaning": "アルゴリズムやビジネスロジックの設計をAIに支援させるプロセス。コード生成やChain-of-Thoughtで段階的にロジックを構築する。",
      "relatedTermIds": ["aidev-term-code-generation", "aidev-term-chain-of-thought"]
    },
    {
      "id": "aidev-concept-pseudocode-generation",
      "term": "Pseudocode Generation",
      "termJa": "擬似コード生成",
      "topicId": "aidev-topic-detailed-design",
      "meaning": "設計仕様からAIに擬似コードやインターフェース定義を生成させるプロセス。トークン制限を意識した粒度で設計することが重要。",
      "relatedTermIds": ["aidev-term-token-limit", "aidev-term-zero-shot", "aidev-term-few-shot"]
    },
    {
      "id": "aidev-concept-test-generation",
      "term": "Test Case Generation",
      "termJa": "テストケースの自動生成",
      "topicId": "aidev-topic-unit-testing",
      "meaning": "実装コードからAIにテストケースを自動生成させるプロセス。正常系・異常系・境界値を網羅的にカバーする。",
      "relatedTermIds": ["aidev-term-test-case-generation", "aidev-term-prompt-engineering"]
    },
    {
      "id": "aidev-concept-coverage-improvement",
      "term": "Coverage Improvement",
      "termJa": "カバレッジ向上",
      "topicId": "aidev-topic-unit-testing",
      "meaning": "ミューテーションテストとAIレビューを組み合わせ、テストの品質を反復的に高めるプロセス。",
      "relatedTermIds": ["aidev-term-mutation-testing", "aidev-term-ai-review"]
    },
    {
      "id": "aidev-concept-scenario-design",
      "term": "Scenario-Based Test Design",
      "termJa": "シナリオベーステスト設計",
      "topicId": "aidev-topic-integration-testing",
      "meaning": "ユースケースや画面遷移図からAIにテストシナリオを生成させるプロセス。例外パスやエッジケースの網羅を支援する。",
      "relatedTermIds": ["aidev-term-test-scenario-generation", "aidev-term-ai-debugging"]
    },
    {
      "id": "aidev-concept-regression-efficiency",
      "term": "Regression Test Efficiency",
      "termJa": "回帰テスト効率化",
      "topicId": "aidev-topic-integration-testing",
      "meaning": "コード変更の影響範囲をAIで分析し、回帰テストの優先順位付けと実行効率化を図るプロセス。",
      "relatedTermIds": ["aidev-term-auto-regression", "aidev-term-code-analysis"]
    },
    {
      "id": "aidev-concept-glossary-creation",
      "term": "Glossary Creation",
      "termJa": "用語集の作成",
      "topicId": "aidev-topic-glossary",
      "meaning": "プロジェクト固有の業務用語・略語・ルールを体系的に整理し、AIの入力に活用できる形式で管理するプロセス。",
      "relatedTermIds": ["aidev-term-glossary-driven", "aidev-term-structured-output", "aidev-term-knowledge-base"]
    },
    {
      "id": "aidev-concept-glossary-prompt-usage",
      "term": "Glossary Prompt Usage",
      "termJa": "用語集のプロンプト活用",
      "topicId": "aidev-topic-glossary",
      "meaning": "用語集をプロンプトに組み込み、AIの出力の一貫性と正確性を高める手法。直接埋め込み、RAG検索、Few-shot例示などの方法がある。",
      "relatedTermIds": ["aidev-term-prompt-template", "aidev-term-rag", "aidev-term-few-shot", "aidev-term-grounding"]
    },
    {
      "id": "aidev-concept-prompt-structure",
      "term": "Prompt Structure",
      "termJa": "プロンプトの構造設計",
      "topicId": "aidev-topic-prompt-patterns",
      "meaning": "役割設定・文脈提供・指示・出力形式の4要素でプロンプトを構造化し、テンプレートとしてチームで共有するプロセス。",
      "relatedTermIds": ["aidev-term-prompt-template", "aidev-term-structured-output"]
    },
    {
      "id": "aidev-concept-prompt-iteration",
      "term": "Prompt Iteration",
      "termJa": "プロンプトの改善サイクル",
      "topicId": "aidev-topic-prompt-patterns",
      "meaning": "プロンプトを出力結果に基づいて反復的に改善し、ナレッジとして蓄積するプロセス。",
      "relatedTermIds": ["aidev-term-knowledge-base", "aidev-term-hallucination", "aidev-term-grounding"]
    },
    {
      "id": "aidev-concept-persistent-rules",
      "term": "Persistent Rules",
      "termJa": "恒常的なルール設定",
      "topicId": "aidev-topic-rules-instructions",
      "meaning": "システムプロンプトやルールファイルを使い、プロジェクト全体に適用されるAIへの指示を一元管理するプロセス。",
      "relatedTermIds": ["aidev-term-system-prompt", "aidev-term-custom-instructions"]
    },
    {
      "id": "aidev-concept-rule-hierarchy",
      "term": "Rule Hierarchy",
      "termJa": "ルールの階層化",
      "topicId": "aidev-topic-rules-instructions",
      "meaning": "全社・プロジェクト・タスクの3階層でルールを構造化し、適切なレベルで管理・適用するプロセス。",
      "relatedTermIds": ["aidev-term-system-prompt", "aidev-term-glossary-driven", "aidev-term-context-window"]
    },
    {
      "id": "aidev-concept-context-design",
      "term": "Context Design",
      "termJa": "コンテキストの設計",
      "topicId": "aidev-topic-context-engineering",
      "meaning": "AIに提供する情報の優先順位・順序・粒度を戦略的に設計し、限られたコンテキストウィンドウの中で出力品質を最大化するプロセス。",
      "relatedTermIds": ["aidev-term-context-engineering", "aidev-term-context-window", "aidev-term-token-limit"]
    },
    {
      "id": "aidev-concept-knowledge-management",
      "term": "Knowledge Management",
      "termJa": "ナレッジ管理",
      "topicId": "aidev-topic-context-engineering",
      "meaning": "設計書・用語集・意思決定記録をナレッジベースに蓄積し、RAGやグラウンディングを通じてAIに提供するプロセス。",
      "relatedTermIds": ["aidev-term-knowledge-base", "aidev-term-rag", "aidev-term-grounding"]
    }
  ],
  "terms": [
    {
      "id": "aidev-term-prompt-engineering",
      "term": "Prompt Engineering",
      "termJa": "プロンプトエンジニアリング",
      "meaning": "AIモデルから望む出力を得るために、入力（プロンプト）を設計・最適化する技術。指示の明確化、文脈の提供、出力形式の指定などが含まれる。開発の全フェーズで基盤となるスキル。",
      "type": "technique",
      "tags": ["基礎", "全フェーズ"]
    },
    {
      "id": "aidev-term-rag",
      "term": "RAG (Retrieval-Augmented Generation)",
      "termJa": "検索拡張生成",
      "meaning": "外部のドキュメントやデータベースから関連情報を検索し、その結果をプロンプトに含めてAIに回答させる手法。社内ドキュメントや過去の設計書を参照した回答が可能になる。",
      "type": "technique",
      "tags": ["設計", "情報検索"]
    },
    {
      "id": "aidev-term-code-generation",
      "term": "Code Generation",
      "termJa": "コード生成",
      "meaning": "自然言語の指示や設計仕様からAIがソースコードを自動生成する技術。擬似コード、テンプレートコード、完全な実装まで様々な粒度で活用できる。",
      "type": "technique",
      "tags": ["実装", "設計"]
    },
    {
      "id": "aidev-term-ai-review",
      "term": "AI Review",
      "termJa": "AIレビュー",
      "meaning": "コードや設計書をAIに読ませ、バグ、設計上の問題、ベストプラクティスからの逸脱を検出させる手法。人間のレビューを補完し、見落としを減らす。",
      "type": "technique",
      "tags": ["品質", "全フェーズ"]
    },
    {
      "id": "aidev-term-test-case-generation",
      "term": "Test Case Generation",
      "termJa": "テストケース生成",
      "meaning": "実装コードや仕様書からAIがテストケースを自動生成する技術。正常系・異常系・境界値を網羅的にカバーし、テスト設計の工数を削減する。",
      "type": "technique",
      "tags": ["テスト", "自動化"]
    },
    {
      "id": "aidev-term-nlp",
      "term": "Natural Language Processing",
      "termJa": "自然言語処理",
      "meaning": "人間の言語をコンピュータが理解・処理するための技術分野。要件定義では、自然言語で書かれた文書の解析、分類、要約に活用される。",
      "type": "theory",
      "tags": ["基礎", "要件定義"]
    },
    {
      "id": "aidev-term-few-shot",
      "term": "Few-shot Learning",
      "termJa": "Few-shot学習",
      "meaning": "AIに少数の例（2〜5件程度）を提示し、パターンを学ばせる手法。過去の要件定義書や設計書の例を示すことで、プロジェクト固有の文脈に沿った出力が得られる。",
      "type": "technique",
      "tags": ["プロンプト", "基礎"]
    },
    {
      "id": "aidev-term-zero-shot",
      "term": "Zero-shot Learning",
      "termJa": "Zero-shot学習",
      "meaning": "例を一切提示せず、指示文のみでAIにタスクを実行させる手法。単純なタスクや汎用的な知識で対応できる場合に有効。Few-shotより手軽だが精度は下がることがある。",
      "type": "technique",
      "tags": ["プロンプト", "基礎"]
    },
    {
      "id": "aidev-term-chain-of-thought",
      "term": "Chain-of-Thought",
      "termJa": "思考連鎖",
      "meaning": "AIに段階的な推論過程を明示させるプロンプト手法。「まず〜を分析し、次に〜を検討し…」と考えさせることで、複雑な設計判断でも論理の飛躍を防ぐ。",
      "type": "technique",
      "tags": ["プロンプト", "設計"]
    },
    {
      "id": "aidev-term-context-window",
      "term": "Context Window",
      "termJa": "コンテキストウィンドウ",
      "meaning": "AIモデルが一度に処理できるテキスト量の上限。設計書やコードを入力する際、この制限を意識して情報を分割・要約する必要がある。モデルにより数千〜数十万トークン。",
      "type": "theory",
      "tags": ["基礎", "制約"]
    },
    {
      "id": "aidev-term-hallucination",
      "term": "Hallucination",
      "termJa": "ハルシネーション",
      "meaning": "AIが事実と異なる情報をもっともらしく生成する現象。存在しないAPIを提案したり、誤った仕様を断言するリスクがある。AIの出力は必ず人間が検証する必要がある。",
      "type": "theory",
      "tags": ["リスク", "全フェーズ"]
    },
    {
      "id": "aidev-term-code-analysis",
      "term": "Code Analysis",
      "termJa": "コード解析",
      "meaning": "既存のソースコードをAIに読ませ、構造・依存関係・処理フローを分析させる技術。大規模コードベースの理解や、変更影響範囲の特定に活用する。",
      "type": "technique",
      "tags": ["設計", "テスト"]
    },
    {
      "id": "aidev-term-embedding-search",
      "term": "Embedding Search",
      "termJa": "エンベディング検索",
      "meaning": "テキストやコードをベクトル化し、意味的な類似度で検索する技術。キーワード一致ではなく、意味が近いコード断片やドキュメントを見つけられる。RAGの基盤技術。",
      "type": "technique",
      "tags": ["情報検索", "設計"]
    },
    {
      "id": "aidev-term-token-limit",
      "term": "Token Limit",
      "termJa": "トークン制限",
      "meaning": "AIモデルへの入力と出力の合計トークン数の上限。長大なコードや設計書を扱う際は、情報の取捨選択や分割が必要。設計粒度にも影響する制約。",
      "type": "theory",
      "tags": ["制約", "設計"]
    },
    {
      "id": "aidev-term-mutation-testing",
      "term": "Mutation Testing",
      "termJa": "ミューテーションテスト",
      "meaning": "ソースコードに意図的な小さな変更（ミューテーション）を加え、テストがその変更を検出できるか検証する手法。テストの品質（検出力）を評価する指標となる。",
      "type": "technique",
      "tags": ["テスト", "品質"]
    },
    {
      "id": "aidev-term-test-scenario-generation",
      "term": "Test Scenario Generation",
      "termJa": "テストシナリオ生成",
      "meaning": "ユースケースや画面遷移図からAIが結合テスト用のシナリオを生成する技術。正常フロー・異常フロー・エッジケースの組み合わせを網羅的に提案する。",
      "type": "technique",
      "tags": ["テスト", "自動化"]
    },
    {
      "id": "aidev-term-ai-debugging",
      "term": "AI Debugging",
      "termJa": "AIデバッグ",
      "meaning": "テスト失敗時のログ、スタックトレース、エラーメッセージをAIに分析させ、原因の特定と修正案の提示を支援する手法。問題の切り分けを効率化する。",
      "type": "technique",
      "tags": ["テスト", "デバッグ"]
    },
    {
      "id": "aidev-term-auto-regression",
      "term": "Automated Regression Testing",
      "termJa": "自動回帰テスト",
      "meaning": "システム変更後に既存機能が正常に動作するか自動検証するプロセス。AIによる変更影響分析と組み合わせ、テスト範囲の最適化と実行効率化を図る。",
      "type": "technique",
      "tags": ["テスト", "自動化"]
    },
    {
      "id": "aidev-term-glossary-driven",
      "term": "Glossary-Driven Development",
      "termJa": "用語集駆動開発",
      "meaning": "プロジェクト固有の用語集を作成・維持し、AIへの全ての入力に用語定義を含めることで出力の一貫性と正確性を担保する開発手法。用語集はコードと同様にバージョン管理する。",
      "type": "technique",
      "tags": ["実践", "全フェーズ"]
    },
    {
      "id": "aidev-term-system-prompt",
      "term": "System Prompt",
      "termJa": "システムプロンプト",
      "meaning": "AIモデルに対して会話全体を通じて適用される初期指示。役割、制約、出力形式などを定義する。ユーザーのプロンプトより優先度が高く、AIの基本的な振る舞いを制御する。",
      "type": "theory",
      "tags": ["基礎", "ルール"]
    },
    {
      "id": "aidev-term-custom-instructions",
      "term": "Custom Instructions",
      "termJa": "カスタム指示",
      "meaning": "CLAUDE.md、.cursorrules、.github/copilot-instructions.md等のファイルを通じてAIツールにプロジェクト固有のルールを伝える仕組み。コーディング規約、技術スタック、禁止事項などを恒常的に適用できる。",
      "type": "technique",
      "tags": ["実践", "ルール"]
    },
    {
      "id": "aidev-term-prompt-template",
      "term": "Prompt Template",
      "termJa": "プロンプトテンプレート",
      "meaning": "繰り返し使うプロンプトの定型フォーマット。固定部分（役割設定、出力形式）と変数部分（対象コード、要件）を分離し、チームで共有することでAI活用の品質を均一化する。",
      "type": "technique",
      "tags": ["実践", "プロンプト"]
    },
    {
      "id": "aidev-term-grounding",
      "term": "Grounding",
      "termJa": "グラウンディング",
      "meaning": "AIの出力を事実や根拠に基づかせる技術。用語集、設計書、公式ドキュメントなどの信頼できる情報源を提供し、AIが根拠のない推測を行うリスクを低減する。ハルシネーション対策の基本手法。",
      "type": "technique",
      "tags": ["品質", "リスク管理"]
    },
    {
      "id": "aidev-term-structured-output",
      "term": "Structured Output",
      "termJa": "構造化出力",
      "meaning": "AIの出力をJSON、Markdown表、YAML等の構造化されたフォーマットで生成させる手法。後続の処理やツール連携が容易になり、出力の一貫性も向上する。",
      "type": "technique",
      "tags": ["実践", "プロンプト"]
    },
    {
      "id": "aidev-term-knowledge-base",
      "term": "Knowledge Base",
      "termJa": "ナレッジベース",
      "meaning": "プロジェクトの設計書、用語集、FAQ、意思決定記録等を体系的に蓄積・管理する仕組み。RAGの検索対象やグラウンディングの根拠として機能し、AIの出力品質の土台となる。",
      "type": "technique",
      "tags": ["実践", "情報管理"]
    },
    {
      "id": "aidev-term-context-engineering",
      "term": "Context Engineering",
      "termJa": "コンテキストエンジニアリング",
      "meaning": "AIに提供する情報（コンテキスト）の選定・構造化・順序設計を行う技術。限られたコンテキストウィンドウの中で、最も効果的な情報の組み合わせを設計し、出力品質を最大化する。",
      "type": "technique",
      "tags": ["実践", "基礎"]
    }
  ]
}
